syntax = "proto3";

package cloudeko.kama.collection.v1;

import "google/api/field_behavior.proto";
import "google/api/field_info.proto";
import "google/api/resource.proto";

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// ----------------------------------------------------------------------------
// Collection Resource Model
// ----------------------------------------------------------------------------
// This file defines the public resource model for collections in the Kama
// platform. A Collection is a server-managed container that defines the schema
// (set of fields) and access rules used to validate and authorize records that
// belong to that collection.
//
// Key concepts:
// - Resource name: Each collection has a stable resource name in the form
//   "collections/{collection}" and an immutable UUID4 id generated by the
//   server.
// - Schema: The schema is represented as a map of field definitions. Each
//   CollectionField can be a scalar, a timestamp, a reference string, raw bytes,
//   a nested array, or a nested map. The schema is used to validate records.
// - Access Rules: Optional Rule entries define authorization logic in CEL that
//   can allow or deny operations based on request, user, and resource context.
// - Timestamps: Server-populated create_time and update_time track the resource
//   lifecycle.
//
// Backward-compatibility guidelines for evolving this API:
// - Only add new optional fields; do not remove or repurpose existing tags.
// - Do not change wire types of existing fields.
// - Prefer adding new enum values to the end. Document behavior of unknown
//   values on clients.
//
// Example (YAML-like) representation of a simple Collection:
//   id: "8d1b9b6a-2f5f-4d1f-8c2c-b5a9ad5e2f5e"
//   name: "collections/products"
//   display_name: "Products"
//   fields:
//     sku:
//       required: true
//       string_type: ""
//     price:
//       required: true
//       double_type: 0
//     tags:
//       required: false
//       array_type:
//         values:
//           - string_type: ""
//   rules:
//     - expression: "request.method == 'read' || user.roles.exists(r, r == 'admin')"
//
// Unless specified otherwise, strings are UTF-8. All server-populated fields are
// marked OUTPUT_ONLY and must be ignored on input.

option java_multiple_files = true;
option java_outer_classname = "ResourcesProto";
option java_package = "dev.cloudeko.kama.collection.v1";
option csharp_namespace = "Cloudeko.Kama.Collection.V1";
option go_package = "cloudeko.dev/go/kama/collection/v1/collectionpb;collectionpb";
option php_namespace = "Cloudeko\\Kama\\Collection\\V1";
option ruby_package = "Cloudeko::Kama::Collection::V1";

// A server-managed container for records with a defined schema and optional
// authorization rules.
message Collection {
  option (google.api.resource) = {
    type: "kama.cloudeko.dev/Collection"
    pattern: "collections/{collection}"
    singular: "collection"
    plural: "collections"
  };

  // Output only. A universally unique identifier (UUID) for the collection in
  // the UUID4 format. This identifier is generated by the server.
  // Example: "8d1b9b6a-2f5f-4d1f-8c2c-b5a9ad5e2f5e"
  string id = 1 [
    (google.api.field_info).format = UUID4,
    (google.api.field_behavior) = OUTPUT_ONLY
  ];

  // Output only. The resource name of the collection in the canonical format.
  // Format: collections/{collection}
  // Example: "collections/products"
  string name = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Optional human-readable name for display purposes.
  // Recommended length: <= 256 characters.
  string display_name = 3 [(google.api.field_behavior) = OPTIONAL];

  // Required. The schema definition of fields in the collection.
  // Keys are field identifiers used by records stored in this collection.
  // - Keys MUST be unique within the map.
  // - Keys SHOULD match ^[a-zA-Z_][a-zA-Z0-9_]*$ for portability.
  // - Values define type and constraints for each field.
  map<string, CollectionField> fields = 4 [(google.api.field_behavior) = REQUIRED];

  // Optional CEL rules governing access. Rules are evaluated in order of
  // appearance. If any rule evaluates to a deny, it should take precedence over
  // allow rules unless the server specifies otherwise. See Rule for details.
  repeated Rule rules = 5 [(google.api.field_behavior) = OPTIONAL];

  // Output only. The last time this collection was updated (server time).
  google.protobuf.Timestamp update_time = 80 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. When this collection was created (server time).
  google.protobuf.Timestamp create_time = 81 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Defines a single field within a Collection schema.
message CollectionField {
  // Whether this field is required on record create/update operations. If
  // required = true, clients must provide a non-null value of the declared type.
  bool required = 1;

  // Declares the data type of this field. Exactly one type must be specified.
  // Notes:
  // - string_type: Arbitrary UTF-8 text. Consider using reference_type if the
  //   value is a resource name or foreign-key reference.
  // - integer_type: 64-bit signed integer.
  // - bool_type: Boolean true/false.
  // - double_type: 64-bit floating point number.
  // - timestamp_type: RFC 3339 UTC timestamp. Use for instants in time.
  // - reference_type: String holding a resource name. Recommended format:
  //     "collections/{collection}/resources/{id}" or fully-qualified resource names.
  // - bytes_type: Opaque binary data. Base64-encoded over JSON.
  // - array_type: Repeating values. See ArrayType for nesting semantics.
  // - map_type: Keyed values. See MapType for nesting semantics.
  oneof type {
    // Free-form UTF-8 text field.
    string string_type = 10;
    // 64-bit signed integer field.
    int64 integer_type = 11;
    // Boolean field.
    bool bool_type = 12;
    // 64-bit IEEE-754 floating point field.
    double double_type = 13;
    // Timestamp (UTC). Clients should send/receive RFC 3339 format in JSON.
    google.protobuf.Timestamp timestamp_type = 14;
    // A string intended to reference another resource (foreign key). Use
    // consistent naming conventions for referenced resource types.
    string reference_type = 15;
    // Opaque binary payload. JSON transports will base64-encode this value.
    bytes bytes_type = 16;
    // An array (list) of values. See ArrayType.values element typing rules.
    ArrayType array_type = 17;
    // A map (object/dictionary) of keyed fields. See MapType.values typing
    // rules.
    MapType map_type = 18;
  }
}

// Describes an array value type. Arrays can be homogeneous or heterogeneous,
// depending on the provided element field definitions.
message ArrayType {
  // Element type(s) for the array. Provide one CollectionField per element type
  // you want to allow. If multiple entries are provided, array elements may be
  // of any of the listed types.
  repeated CollectionField values = 1;
}

// Describes a map (object) value type. Keys MUST be unique strings.
message MapType {
  // Field definitions of the map's values. Each key defines the allowed field
  // name and its type and constraints.
  map<string, CollectionField> values = 1;
}

// An authorization rule expressed in CEL. Rules are evaluated with access to
// the following variables:
// - resource: The target resource (e.g., a Collection or its Records).
// - request: The incoming request context (method, parameters, etc.).
// - user: The authenticated user context (id, roles, attributes).
// Example expressions:
//   user.roles.exists(r, r == 'admin')
//   request.method == 'read' && resource.name.startsWith('collections/public')
message Rule {
  // Required. Logic expression for the rule in the CEL language.
  // Input variables for the expression are:
  // `resource`: The resource being accessed.
  // `request`: The request being made.
  // `user`: The user making the request.
  string expression = 1;

  // Defines the effect of a rule evaluation.
  message RuleType {

    enum Type {
      // Default/unspecified behavior. Servers should treat this as deny-safe
      // or ignore the rule, depending on implementation.
      TYPE_UNSPECIFIED = 0;
      // Explicit allow if expression evaluates to true.
      TYPE_ALLOW = 1;
      // Explicit deny if expression evaluates to true. Typically takes
      // precedence over allow.
      TYPE_DENY = 2;
    }

    // The effect this rule has when its expression evaluates to true.
    Type type = 1;
  }
}

//TODO: Edit and document this
message ValidationRules {
  // String validations
  int32 min_length = 1;
  int32 max_length = 2;
  string pattern = 3; // Regex pattern

  // Numeric validations
  double min_value = 4;
  double max_value = 5;

  // Array validations
  int32 min_items = 6;
  int32 max_items = 7;

  // Reference validations
  string reference_collection = 8;
}